<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="Skogestad" Id="{aa431b1a-4355-4557-bb11-a5f63cc0b804}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK Skogestad EXTENDS ParallelPID
VAR_INPUT
    // Set in superclass
END_VAR
VAR_OUTPUT
    // Set in superclass
END_VAR

VAR
    loadConfig: BOOL := FALSE; 		// Use stored system dynamics if true

    k1: REAL := 3.0;				
    lambda: REAL := 0.0;    		// Measured dead time or delta time

    // Temperature step-response variables
    baselineTemp: REAL := 0.0;
    stepTemp: REAL := 0.0;
    stepTime: REAL := 0;
	
	// Stability check
	checkStability: CheckStability;
    rStableWaitTime: REAL := 20;
	runningStableThreshold: REAL := 0.1;
    stabilized: BOOL := FALSE;
    stableTemp: REAL := 0;
    
	// Controller output
	currentOutput: INT := 0;
    baselineOutput: INT := 4;
    stepOutput: INT := 6;
	
	// System dynamics measurement data
    arTemp: ARRAY[0..10000] OF REAL;
    arTime: ARRAY[0..10000] OF REAL;
    currentIndex: INT := 0;

	// Processing variables
    lowestTemp: REAL := 9999;
    baselineTime: REAL := 0;
    measureTemp: REAL := 0;
    initTemp: REAL := 0.0;
	i: INT := 0;

    tuningPhase: TunePhase := TunePhase.init; 	// Current tuning phase
END_VAR
VAR PERSISTENT 
    // Store measured system dynamics for recalculation
    riseTime: REAL := 0;
    k: REAL := 0;
    deadTime: REAL := 0;
    
    // Persistent variables for asynchronous batch writing
    batchWritePending: BOOL := FALSE;
    batchTemp: ARRAY[0..50] OF REAL;  // holds one batch of temp data
    batchTime: ARRAY[0..50] OF REAL;  // holds one batch of time data
END_VAR
// Use temporary arrays for the batch.
VAR_TEMP
	j: INT;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[//
//	TODO: Less measurements, maybe on each change?
//

IF tuningPhase = TunePhase.init THEN
	currentOutput := 0; // Ensure output is off
	
	IF loadConfig THEN
		tuningPhase := TunePhase.done;	// Skip tuning if using stored variables
		RETURN;
	END_IF
	
    // Wait for stabilization before starting tuning.
    checkStability(rCurrentValue := rFeedbackVariable, 
                   rDeltaTime := rDeltaTime, 
                   rThreshold := 0.4, 
                   rDuration := 15,
                   rInitialValue := -99.9, 
                   bIsStable => stabilized, 
                   rStabilizedOutput => stableTemp);
    IF stabilized THEN
        tuningPhase := TunePhase.baseline;
		currentOutput := baselineOutput;
		initTemp := stableTemp;
        stabilized := FALSE;
    ELSE
        RETURN;
    END_IF

ELSIF tuningPhase = TunePhase.baseline THEN
	// Collect data in baseline phase
	arTime[currentIndex] := rDeltaTime;
	arTemp[currentIndex] := GVL.rTempSensor;
	currentIndex := currentIndex + 1;	

    IF stabilized THEN
		tuningPhase := TunePhase.step;
        currentOutput := stepOutput;
		baselineTemp := stableTemp;
		initTemp := stableTemp;
        stabilized := FALSE;
    END_IF
	
ELSIF tuningPhase = TunePhase.step THEN
	// Collect data in step phase
	arTime[currentIndex] := rDeltaTime;
	arTemp[currentIndex] := GVL.rTempSensor;
	currentIndex := currentIndex + 1;
	IF currentIndex > 9999 THEN
		currentIndex := 0;
	END_IF		

    IF stabilized THEN
        stepTemp := stableTemp;
        k := (stepTemp - baselineTemp) / (stepOutput - baselineOutput);
		
        // Compute dead-time
        deadTime := 0.0;
        riseTime := 0.0;
        lowestTemp := 9999;
        FOR i := 0 TO currentIndex - 1 DO
            IF arTemp[i] < lowestTemp THEN
                lowestTemp := arTemp[i];
            END_IF;
            IF arTemp[i] > lowestTemp + 0.002 * (stepTemp - lowestTemp) THEN
                EXIT;
            ELSE
                deadTime := deadTime + arTime[i];
            END_IF;
        END_FOR;
		
        // Compute rise-time (63.2% response)
        measureTemp := baselineTemp + 0.632 * (stepTemp - baselineTemp);
        baselineTime := 0.0;
        FOR i := 0 TO currentIndex - 1 DO
            riseTime := riseTime + arTime[i];
            IF arTemp[i] > baselineTemp THEN 
                baselineTime := riseTime;
                baselineTemp := 3.402823E+38; // Lock value
            END_IF;
            IF arTemp[i] > measureTemp THEN
                EXIT;
            END_IF;
        END_FOR;
        riseTime := riseTime - baselineTime;
		
        tuningPhase := TunePhase.done;
		currentOutput := 0;
    END_IF
	
ELSIF tuningPhase = TunePhase.done THEN
    // Calculate final PID gains.
    k1 := riseTime / (deadTime + deadTime);
    lambda := MAX(deadTime, rDeltaTime);
    GVL.kp := riseTime / (k * (lambda + deadTime));
    GVL.ki := GVL.kp / MIN(riseTime, k1 * (lambda + deadTime));
    GVL.kd := 0;
	
	GVL.doTuning := FALSE; // Let PID controller take over
	
END_IF

// If at least 101 samples collected and no batch is pending, store the first 101 values
IF (currentIndex >= 51) AND (NOT batchWritePending) THEN
    FOR j := 0 TO 50 DO
         batchTemp[j] := arTemp[j];
         batchTime[j] := arTime[j];
    END_FOR;
    batchWritePending := TRUE;
END_IF;

// If a batch write is pending, call M_WriteData repeatedly until it returns TRUE.
IF batchWritePending THEN
    // M_WriteData is asynchronous. It must be called each cycle until it returns TRUE.
    IF M_WriteData(tempData := batchTemp, timeData := batchTime) THEN
         // Write complete. Now shift remaining data (if any) from arTemp and arTime.
         IF currentIndex > 51 THEN
              // Shift remaining samples to start of arrays
              FOR j := 0 TO currentIndex - 51 - 1 DO
                   arTemp[j] := arTemp[j + 51];
                   arTime[j] := arTime[j + 51];
              END_FOR;
              currentIndex := currentIndex - 51;
         ELSE
              currentIndex := 0;
         END_IF;
         batchWritePending := FALSE;
    END_IF;
END_IF;

GVL.iHeaterActuator := currentOutput;
iOutput := currentOutput;
]]></ST>
    </Implementation>
    <Method Name="M_WriteData" Id="{626e2e9f-860d-4e7f-a600-8b786b180d29}">
      <Declaration><![CDATA[METHOD PRIVATE M_WriteData : BOOL
VAR_INPUT
    tempData: ARRAY[0..50] OF REAL;
    timeData: ARRAY[0..50] OF REAL;
END_VAR
VAR
    sPath   : STRING(80) := 'C:\Temp\DataLog.txt';
    sNetId  : T_AmsNetId := '192.168.22.61.1.1';  // Target system (empty is local)
    i       : INT;
END_VAR
VAR_STAT
	sLine   : STRING(255);
	hFile   : UINT;
	fbOpen : FB_FileOpen;
    fbWrite: FB_FileWrite;
    fbClose: FB_FileClose;
    state : INT := 0;  // 0: open, 1: write, 2: close, 3: error
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE state OF
    0: // Open file in append mode
         fbOpen(
             sNetId := sNetId,
             sPathName := sPath,
             nMode := FOPEN_MODEAPPEND OR FOPEN_MODETEXT,
             ePath := PATH_GENERIC,
             bExecute := TRUE
         );
         IF NOT fbOpen.bBusy THEN
             IF fbOpen.bError THEN
                 state := 3;
                 M_WriteData := FALSE;
             ELSE
                 hFile := fbOpen.hFile;
                 state := 1;
             END_IF;
             fbOpen(bExecute := FALSE);
         END_IF;
         
    1: // Build CSV line: tempData values, '#' delimiter, then timeData values, then newline
		// Each new line represents a batch
         sLine := '';
         // Append tempData values
         FOR i := 0 TO 50 DO
             sLine := CONCAT(sLine, REAL_TO_STRING(tempData[i]));
             IF i < 50 THEN
                 sLine := CONCAT(sLine, ',');
             END_IF;
         END_FOR;
         // Append delimiter
         sLine := CONCAT(sLine, '#');
         // Append timeData values
         FOR i := 0 TO 50 DO
             sLine := CONCAT(sLine, REAL_TO_STRING(timeData[i]));
             IF i < 50 THEN
                 sLine := CONCAT(sLine, ',');
             END_IF;
         END_FOR;
         // Append newline
         sLine := CONCAT(sLine, '\r\n');
         
         fbWrite(
             sNetId := sNetId,
             hFile := hFile,
             pWriteBuff := ADR(sLine),
             cbWriteLen := INT_TO_UDINT(LEN(sLine)),
             bExecute := TRUE
         );
         IF NOT fbWrite.bBusy THEN
             IF fbWrite.bError THEN
                 state := 3;
                 M_WriteData := FALSE;
             ELSE
                 state := 2;
             END_IF;
             fbWrite(bExecute := FALSE);
         END_IF;
         
    2: // Close file
         fbClose(
             sNetId := sNetId,
             hFile := hFile,
             bExecute := TRUE
         );
         IF NOT fbClose.bBusy THEN
             fbClose(bExecute := FALSE);
             state := 0;
             M_WriteData := TRUE;
         END_IF;
         
    3: // Error: reset state
         state := 0;
         M_WriteData := FALSE;
END_CASE;
]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>